## JVM组成
1. 类加载器
2. 运行时数据区
3. 执行引擎
4. 本地接口库

![](/media/jvm.jpg)

![](/media/jvm2.jpg)

## 类加载器
`JVM把描述类的数据从二进制字节码文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的java类型，这个过程被称为虚拟机的类加载机制。`
###分类
1. 启动类加载器
2. 扩展类加载器
3. 应用程序类加载器
4. 双亲委派模型
	- 一个类加载器接收到类加载任务，会先交给父类加载器去完成，只有确认父类加载器无法完成加载任务时，才会尝试进行类加载
	- 类加载器和全限定类名才能确定其在JVM中的唯一性。
### 类加载过程
1. 加载
	- 通过一个类的全限定类名来获取其定义的二进制字节流
	- 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
	- 在`堆`中生成一个代表这个类的Class对象，作为方法区中这些数据的访问入口
	- 类变量（静态变量）随着 Class 对象一起存放到堆中。
2. 连接
	- 验证
		- 确保 Class 文件的字节流中包含的信息符合JVM规范的全部约束要求，确保这些信息被当作代码运行以后不会危害JVM自身。
	- 准备
		- 正式为类中定义的变量（静态变量）分配内存并设置类变量初始值的阶段（类变量、实例变量、局部变量）
		- 实例对象会在对象实例化时随着对象一起分配到堆中。
	- 解析
		- JVM将常量池内的符号引用替换为直接引用的过程（符号引用：在二进制字节码内定位常量；直接引用：在JVM虚拟机内定位常量）。
3. 初始化
	- 执行类构造器方法的过程。
	
	
	
## 运行时数据区
### JVM内存模型
1. 程序计数器
	- 当前线程所执行的字节码的行号指示器，控制程序执行流程：分支，循环，跳转，异常处理，线程恢复。
	- 每条线程都有一个独立的程序计数器，是“线程的私有”内存。
	- 若执行的是本地（Native）方法，这个计数器的值应该为空
2. Java虚拟机栈
	- 描述的是“Java方法执行的线程内存模型”
	- 也是线程私有的！
	- 每个方法执行的时候，Java虚拟机都会同步创建一个栈帧用于存储：局部变量表（存放了编译期可知的各种Java虚拟机基本数据类型，对象引用，returnAddress）、操作数栈、动态链接、方法出口等信息。
3. 本地方法栈
	- 为虚拟机使用到的本地（Native）方法服务。
4. Java堆
	- 被所有线程共享
	- 从分配内存的角度看，所有线程共享的Java堆可以划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer）（TLAB）
	- 只存放对象实例。
	- 逻辑上连续
	- 字符串常量池
5. 方法区
	- 线程共享
	- 用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。
	- JDK6之前，永久代是方法区的一种实现，但JDK6之后已经开始逐渐放弃永久代，转用本地内存来实现方法区了。
	- JDK8完全放弃永久代的概念，改用在本地内存中实现的元空间（Mate-space）来代替
		- 永久代容易导致内存溢出问题
	- 运行时常量池、静态常量池保存在元空间中
	- 字符串常量池保存在堆中！
		- 字面量：java语言层面的常量概念
		- 符号引用： 类和接口的全限定类名；字段名称和描述符；方法名和描述符；
### 垃圾回收算法
|收集器|串行/并行/并发|新生代/老年代|算法|目标|适用场景|
|---------|---------|--------------|------|---|--------|
|Serial|串行|新生代|复制算法|响应速度优先|单CPU环境下的client模式|
|Serial Old|串行|老年代|标记-整理|响应速度优先|单CPU环境下的client模式|
|Parallel Scavenge|并行|新生代|复制算法|吞吐量优先|在后台运算而不需要太多交互的任务|
|Parallel Old|并行|老年代|标记-整理|吞吐量优先|在后台运算而不需要太多交互的任务| 
|ParNew|并行|新生代|复制算法|响应速度优先|多CPU环境时在Server模式下与CMS配合|
|CMS|并发|老年代|标记-清除|响应速度优先|集中在互联网站或B/S系统服务端上的java应用|
|G1|并发|both|标记-整理+复制算法|响应速度优先|面型服务端应用|
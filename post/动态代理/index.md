## 代理模式
1. 控制对基础对象的访问
2. 在访问时增加额外的功能
## 代理模式和装饰器模式
1. 代理模式是在被代理对象不能或者不容易获取的情况下，对被代理对象进行访问控制，强调的代理；
2. 装饰器模式其实是继承的一种代替方案，被装饰的对象是比较容易或者已经被获得了，只不过要在原来的功能上添加更强大的功能！
## 动态代理
1. 静态代理需要生成代理类，代理类的Class文件在编译期生成
2. 动态代理利用反射机制在运行时生成代理类的字节码，代理类在编译阶段并不存在；本质上是代理类和基础接口的解耦。
## 基于jdk的动态代理
1. 代理流程
	- 使用Proxy类的newProxyInstance方法来得到代理类
	- 包括三个参数
		- 被代理对象的类加载器：类加载器和全限定类名才能唯一确定一个对象
		- 被代理对象的接口数组：通过反射
		- InvoccationHandler对象：作为一个代理类的成员变量存在
	- 三个参数的作用 
		- 为接口创建代理类的字节码文件
		- 用类加载器将字节码文件加载到jvm
		- 创建代理类的实例对象，执行对象的目标方法
2. 达到的效果
	- 被代理对象的所有方法都被以相同的方式增强
3. 代理对象的结构
	- InvocationHandler成员变量
	- 调用代理对象的每一个方法的本质其实都是调用InvocationHandler的invoke方法，也就是说会被invoke拦截
	- 同时会将代理对象、本方法的Method变量（通过反射得到）、本方法的参数传给invocake方法！
	- 在InvocationHandler的invoke方法中需要做的是对方法进行增强，并通过反射的方式调用原来的方法！
## 基于cglib的动态代理

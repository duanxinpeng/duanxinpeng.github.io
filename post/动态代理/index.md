## 代理模式
1. 控制对基础对象的访问
2. 在访问时增加额外的功能
## 动态代理
1. 静态代理需要生成代理类，代理类的Class文件在编译期生成
2. 动态代理利用反射机制在运行时生成代理类的字节码，代理类在编译阶段并不存在；本质上是代理类和基础接口的解耦。
## 基于jdk的动态代理
1. 代理流程
	- 使用Proxy类的newProxyInstance方法来得到代理类
	- 包括三个参数
		- 被代理对象的类加载器：类加载器和全限定类名才能唯一确定一个对象
		- 被代理对象的接口数组：通过反射
		- InvoccationHandler对象：作为一个代理类的成员变量存在
2. 达到的效果
	- 被代理对象的所有方法都被以相同的方式增强
3. 代理对象的结构
	- InvocationHandler成员变量
	- 调用代理对象的每一个方法的本质其实都是调用InvocationHandler的invoke方法，也就是说会被invoke拦截
	- 同时会将代理对象、本方法的Method变量（通过反射得到）、本方法的参数传给invocake方法！
	- 在InvocationHandler的invoke方法中需要做的是对方法进行增强，并通过反射的方式调用原来的方法！
## 基于cglib的动态代理

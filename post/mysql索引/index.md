## 为什么不用哈希表？
1. 哈希函数难以设计
2. 需要大量的内存空间
3. 不方便范围查询
## 会自动为主键创建索引吗？
1. 如果表设置了主键，会自动为主键创建索引 
2. 如果没有主键，则会默认为第一个非空且唯一的列创建索引
3. 以上都没有，则会默认为一个隐藏的 row_id 创建索引
4. 在InnoDB引擎中，以上索引都是聚簇索引。
## 索引分类
1. 主键索引：主键会被自动建索引。
2. 唯一索引：要求不能有重复数据，
3. 普通索引/二级索引/辅助索引：为某一列创建一个索引，其数据存放的是主键，而不是实际的行数据！所以属于非聚簇索引！
3. 聚簇索引：
4. 非聚簇索引：
5. 联合索引：
## 存储引擎
1. innodb
	- 支持事务
	- 数据索引放一块，innbdb的主键索引，唯一索引都是聚簇索引，叶子节点中存放的都是行数据
2. memory
	- 数据存放在内存中
3. myisam：存储成三个文件
	- 不支持事务（存储速度更快）
	- 索引和数据分开放，所以都是非聚簇索引！
## 基础概念
1. 回表：两次遍历B+树，一次通过普通索引查找 key，再通过key找到行数据。
2. 索引覆盖：所查询数据就在辅助索引上，所以不需要回表，实现的方法是建立联合索引！

## 联合索引
1. 为什么不为每一列创建索引？
	- 索引覆盖 
	- 减少开销
2. 最左匹配：只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。利用索引对列进行匹配时，从左向右进行匹配，一旦中间某个列不在查询条件中，那么其后的索引都不起作用了。类似字符串通过字典顺序比较大小，中间有个字母跳过了，两个字符串的大小就没办法确定。
## 索引创建
1. 创建普通索引：ALTER TABLE table_name `ADD INDEX` index_name(column_list)
2. 创建唯一索引：ALTER TABLE table_name `ADD UNIQUE` (column_list)
3. 创建主键索引：ALTER TABLE table_name `ADD PRIMARY KEY` (column_list)
4. 创建联合索引：ALTER TABLE table_name `ADD INDEX` index_name(column_list1，column_list2,...)
## MySQL中如果使用like进行模糊匹配的时候，是否会使用索引？
1. 模糊匹配时，当前面select查询的字段在索引树上时，会使用索引，但是是通过全局扫描所引树来找到响应的字段，因为需要查询的字段都在索引树上。